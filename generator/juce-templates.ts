/**
 * JUCE Audio Plugin Template Files
 *
 * Functions to generate template files for JUCE audio plugin projects.
 */

import type { JucePluginConfig } from "./generate.ts";

// =============================================================================
// CMake
// =============================================================================

export function generateJuceCMakeLists(config: JucePluginConfig): string {
  return `# JUCE Audio Plugin CMakeLists.txt
# Generated by deno-juce-project-generator

cmake_minimum_required(VERSION 3.22)

project(${config.nameUpper} VERSION ${config.version})

option(TARGET_UNIVERSAL_BINARY "Build universal binary for macOS" ON)

# Enable folder organization in Visual Studio Solution Explorer
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# Compile commands, useful for some IDEs like VS-Code
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# ============== Platform settings ==============
# Xcode 15 linker workaround
if (CMAKE_CXX_COMPILER_ID MATCHES "AppleClang")
    if (NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS "15.0")
        add_compile_definitions(JUCE_SILENCE_XCODE_15_LINKER_WARNING=1)
        set(CMAKE_EXE_LINKER_FLAGS "-Wl,-ld_classic" CACHE INTERNAL "")
    endif ()
endif ()

if(APPLE)
    if(CMAKE_SYSTEM_NAME STREQUAL "iOS")
        # iOS configuration
        message(STATUS "Configuring for iOS")
        set(CMAKE_OSX_DEPLOYMENT_TARGET "11.0" CACHE STRING "Minimum OS X deployment version" FORCE)

        # iOS architectures (device + simulator)
        set(CMAKE_OSX_ARCHITECTURES "arm64;x86_64" CACHE INTERNAL "")

        # iOS-specific additional settings
        set(CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM "YOUR_TEAM_ID" CACHE STRING "" FORCE)

    elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
        # macOS configuration
        message(STATUS "Configuring for macOS")
        set(CMAKE_OSX_DEPLOYMENT_TARGET "11.0" CACHE STRING "Minimum OS X deployment version" FORCE)

        # Set universal binary with option variable
        if (TARGET_UNIVERSAL_BINARY)
            set(CMAKE_OSX_ARCHITECTURES "x86_64;arm64" CACHE INTERNAL "")
        endif ()
    endif()
endif()

if(CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL "MSVC")
    # Static linking in Windows platform
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
endif()

if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    # For building in multibyte language environment
    add_compile_options(/utf-8)
endif()

# Add JUCE from External directory
add_subdirectory(External/JUCE)

# \`juce_add_plugin\` adds a static library target with the name passed as the first argument.
# This target is a normal CMake target, but has a lot of extra properties set up by default.
# This function accepts many optional arguments. Check the readme at
# \`docs/CMake API.md\` in the JUCE repo for the full list.

juce_add_plugin(${config.namePascal}
    # VERSION ...                               # Set this if the plugin version is different to the project version
    # ICON_BIG ...                              # ICON_* arguments specify a path to an image file to use as an icon for the Standalone
    # ICON_SMALL ...
    COMPANY_NAME "${config.author}"
    BUNDLE_ID "com.${config.author.replace(/\s+/g, "").toLowerCase()}.${config.namePascal.toLowerCase()}"
    # IS_SYNTH TRUE/FALSE                       # Is this a synth or an effect?
    # NEEDS_MIDI_INPUT TRUE/FALSE               # Does the plugin need midi input?
    # NEEDS_MIDI_OUTPUT TRUE/FALSE              # Does the plugin need midi output?
    # IS_MIDI_EFFECT TRUE/FALSE                 # Is this plugin a MIDI effect?
    # EDITOR_WANTS_KEYBOARD_FOCUS TRUE/FALSE    # Does the editor need keyboard focus?
    # COPY_PLUGIN_AFTER_BUILD TRUE/FALSE        # Should the plugin be installed to a default location after building?
    PLUGIN_MANUFACTURER_CODE ${config.manufacturerCode}
    PLUGIN_CODE ${config.pluginCode}
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "${config.name}")

# \`juce_generate_juce_header\` will create a JuceHeader.h for a given target, which will be generated
# into your build tree. This should be included with \`#include <JuceHeader.h>\`.

juce_generate_juce_header(${config.namePascal})

# \`target_sources\` adds source files to a target.

target_sources(${config.namePascal}
    PRIVATE
        Source/PluginEditor.cpp
        Source/PluginProcessor.cpp)

# \`target_compile_definitions\` adds some preprocessor definitions to our target.

target_compile_definitions(${config.namePascal}
    PUBLIC
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0)

# If your target needs extra binary assets, you can add them here.
# juce_add_binary_data(AudioPluginData SOURCES ...)

# \`target_link_libraries\` links libraries and JUCE modules to other libraries or executables.

target_link_libraries(${config.namePascal}
    PRIVATE
        # AudioPluginData           # If we'd created a binary data target, we'd link to it here
        juce::juce_audio_utils
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_lto_flags
        juce::juce_recommended_warning_flags)
`;
}

// =============================================================================
// Deno Build System
// =============================================================================

export function generateJuceDenoJson(): string {
  return `{
  "tasks": {
    "build": "deno run --allow-all build.ts",
    "build:debug": "deno run --allow-all build.ts --config Debug",
    "build:release": "deno run --allow-all build.ts --config Release",
    "clean": "deno run --allow-all build.ts --clean",
    "rebuild": "deno run --allow-all build.ts --clean && deno run --allow-all build.ts --config Release",
    "run": "deno run --allow-all build.ts --run",
    "run:debug": "deno run --allow-all build.ts --run --config Debug",
    "format": "deno fmt",
    "format:check": "deno fmt --check",
    "lint": "deno lint"
  },
  "fmt": {
    "include": ["build.ts", "build.config.ts", "cmake-file-api.ts", "cmake-types.ts", "vs-detector.ts"]
  },
  "lint": {
    "include": ["build.ts", "build.config.ts", "cmake-file-api.ts", "cmake-types.ts", "vs-detector.ts"]
  }
}
`;
}

export function generateJuceBuildConfig(config: JucePluginConfig): string {
  return `export interface BuildConfig {
  projectName: string;
  pluginName: string;
  version: string;
  author: string;
  buildTypes: string[];
  vsVersion?: string;
}

export const config: BuildConfig = {
  projectName: "${config.nameUpper}",
  pluginName: "${config.namePascal}",
  version: "${config.version}",
  author: "${config.author}",
  buildTypes: ["Debug", "Release"],${config.vsVersion ? `\n  vsVersion: "${config.vsVersion}",` : ""}
};
`;
}

export function generateJuceBuildScript(): string {
  return `#!/usr/bin/env -S deno run --allow-all

import $ from "jsr:@david/dax@0.42.0";
import { parseArgs } from "jsr:@std/cli@1.0.6/parse-args";
import { exists } from "jsr:@std/fs@1.0.8/exists";
import { config } from "./build.config.ts";
import {
  setupFileAPI,
  parseFileAPI,
  printArtifacts,
} from "./cmake-file-api.ts";
import type { BuildArtifact } from "./cmake-types.ts";
import { getDefaultVSGenerator } from "./vs-detector.ts";

// Parse command line arguments
const args = parseArgs(Deno.args, {
  boolean: ["clean", "run"],
  string: ["config", "generator"],
  default: {
    config: "Release",
  },
});

async function getDefaultGenerator(): Promise<string> {
  switch (Deno.build.os) {
    case "windows":
      return await getDefaultVSGenerator(config.vsVersion);
    case "darwin":
      return "Xcode";
    default:
      return "Unix Makefiles";
  }
}

async function clean(): Promise<void> {
  console.log("üßπ Cleaning build directory...");
  await $\`rm -rf build\`;
}

async function configure(): Promise<void> {
  console.log("‚öôÔ∏è  Configuring CMake...");

  await $\`mkdir -p build\`;

  // Setup File API query
  await setupFileAPI("build");

  const generator = args.generator || await getDefaultGenerator();

  // Run CMake configuration
  if (Deno.build.os === "windows") {
    await $\`cmake -B build -G \${generator}\`;
  } else if (Deno.build.os === "darwin") {
    await $\`cmake -B build -G \${generator}\`;
  } else {
    await $\`cmake -B build -DCMAKE_BUILD_TYPE=\${args.config} -G \${generator}\`;
  }
}

async function build(): Promise<BuildArtifact[]> {
  console.log("üî® Building plugin...");

  await $\`cmake --build build --config \${args.config}\`;

  // Auto-detect build artifacts
  const artifacts = await parseFileAPI("build");
  printArtifacts(artifacts);

  return artifacts;
}

function getStandalonePath(): string {
  const artefactsBase = \`build/\${config.pluginName}_artefacts/\${args.config}\`;

  switch (Deno.build.os) {
    case "windows":
      return \`\${artefactsBase}/Standalone/\${config.pluginName}.exe\`;
    case "darwin":
      return \`\${artefactsBase}/Standalone/\${config.pluginName}.app/Contents/MacOS/\${config.pluginName}\`;
    default:
      return \`\${artefactsBase}/Standalone/\${config.pluginName}\`;
  }
}

async function runStandalone(): Promise<void> {
  const standalonePath = getStandalonePath();

  console.log(\`üöÄ Running Standalone: \${standalonePath}\`);

  if (!(await exists(standalonePath))) {
    console.error(\`‚ùå Standalone not found: \${standalonePath}\`);
    console.error("   Run 'deno task build' first to build the plugin.");
    Deno.exit(1);
  }

  await $\`\${standalonePath}\`;
}

// Main entry point
async function main(): Promise<void> {
  try {
    const generator = args.generator || await getDefaultGenerator();

    console.log(\`üéπ \${config.pluginName} v\${config.version}\`);
    console.log(\`   Configuration: \${args.config}\`);
    console.log(\`   Platform: \${Deno.build.os}\`);
    console.log(\`   Generator: \${generator}\`);
    console.log("");

    if (args.clean) {
      await clean();
      Deno.exit(0);
    }

    if (args.run) {
      // Build if not already built, then run
      const standalonePath = getStandalonePath();
      if (!(await exists(standalonePath))) {
        await configure();
        await build();
      }
      await runStandalone();
      Deno.exit(0);
    }

    await configure();
    await build();

    console.log("\\n‚úÖ Build completed successfully!");
    console.log(\`\\nüì¶ Plugin artifacts are in: build/\${config.pluginName}_artefacts/\${args.config}/\`);
  } catch (error) {
    console.error("‚ùå Build failed:", error.message);
    Deno.exit(1);
  }
}

await main();
`;
}

export function generateJuceCMakeFileAPI(): string {
  return `import $ from "jsr:@david/dax@0.42.0";
import { walk } from "jsr:@std/fs@1.0.8/walk";
import { join, normalize } from "jsr:@std/path@1.0.8";
import type {
  FileAPIIndex,
  CodeModelV2,
  TargetInfo,
  BuildArtifact,
} from "./cmake-types.ts";

/**
 * Generate CMake File API query file
 */
export async function setupFileAPI(buildDir: string): Promise<void> {
  const queryDir = join(buildDir, ".cmake", "api", "v1", "query");
  await $\`mkdir -p \${queryDir}\`;

  // Request codemodel-v2
  const queryFile = join(queryDir, "codemodel-v2");
  await Deno.writeTextFile(queryFile, "");

  console.log("‚úÖ CMake File API query created");
}

/**
 * Parse CMake File API response
 */
export async function parseFileAPI(
  buildDir: string
): Promise<BuildArtifact[]> {
  const replyDir = join(buildDir, ".cmake", "api", "v1", "reply");

  // Check if reply directory exists
  try {
    await Deno.stat(replyDir);
  } catch {
    throw new Error(
      \`CMake File API reply directory not found: \${replyDir}\\nRun cmake configure first.\`
    );
  }

  // Find index files using Deno's walk
  const indexFiles: string[] = [];
  for await (const entry of walk(replyDir, { maxDepth: 1, includeFiles: true, includeDirs: false })) {
    if (entry.name.startsWith("index-") && entry.name.endsWith(".json")) {
      indexFiles.push(entry.path);
    }
  }

  if (indexFiles.length === 0) {
    throw new Error(
      \`CMake File API index file not found in \${replyDir}\\nRun cmake configure first.\`
    );
  }

  // Read the latest index file (sorted by filename)
  indexFiles.sort();
  const indexPath = indexFiles[indexFiles.length - 1];

  console.log(\`üìÑ Reading CMake File API: \${indexPath}\`);

  const index: FileAPIIndex = JSON.parse(
    await Deno.readTextFile(indexPath)
  );

  // Get codemodel-v2
  const codemodelRef = index.reply["codemodel-v2"];
  if (!codemodelRef) {
    throw new Error("codemodel-v2 not found in File API response");
  }

  const codemodelPath = join(replyDir, codemodelRef.jsonFile);
  const codemodel: CodeModelV2 = JSON.parse(
    await Deno.readTextFile(codemodelPath)
  );

  // Collect target information
  const artifacts: BuildArtifact[] = [];

  for (const config of codemodel.configurations) {
    for (const targetRef of config.targets) {
      const targetPath = join(replyDir, targetRef.jsonFile);
      const target: TargetInfo = JSON.parse(
        await Deno.readTextFile(targetPath)
      );

      // Include various target types for JUCE plugins
      if (
        target.type === "EXECUTABLE" ||
        target.type === "STATIC_LIBRARY" ||
        target.type === "SHARED_LIBRARY" ||
        target.type === "MODULE_LIBRARY"
      ) {
        if (target.artifacts && target.artifacts.length > 0) {
          for (const artifact of target.artifacts) {
            // Normalize path (CMake uses forward slashes)
            const artifactPath = artifact.path.replace(/\\\\/g, "/");
            const fullPath = normalize(join(codemodel.paths.build, artifactPath));

            artifacts.push({
              name: target.name,
              type: target.type,
              path: fullPath,
            });
          }
        }
      }
    }
  }

  return artifacts;
}

/**
 * Print build artifacts
 */
export function printArtifacts(artifacts: BuildArtifact[]): void {
  console.log("\\nüì¶ Build Artifacts:");
  console.log("‚îÄ".repeat(80));

  const grouped = new Map<string, BuildArtifact[]>();

  for (const artifact of artifacts) {
    if (!grouped.has(artifact.type)) {
      grouped.set(artifact.type, []);
    }
    grouped.get(artifact.type)!.push(artifact);
  }

  for (const [type, items] of grouped) {
    console.log(\`\\n\${type}:\`);
    for (const item of items) {
      console.log(\`  ‚Ä¢ \${item.name}\`);
      console.log(\`    \${item.path}\`);
    }
  }

  console.log("\\n" + "‚îÄ".repeat(80));
}
`;
}

export function generateVSDetector(): string {
  return `/**
 * Visual Studio Version Detection Utility
 *
 * Detects installed Visual Studio versions on Windows.
 * Supports Visual Studio 2019, 2022, and 2026.
 */

import { join } from "jsr:@std/path@1.0.8";

export interface VSVersion {
  year: string;
  version: string;
  generator: string;
  path?: string;
}

// Supported Visual Studio versions
export const SUPPORTED_VS_VERSIONS: VSVersion[] = [
  {
    year: "18",
    version: "18",
    generator: "Visual Studio 18 2026",
  },
  {
    year: "2022",
    version: "17",
    generator: "Visual Studio 17 2022",
  },
  {
    year: "2019",
    version: "16",
    generator: "Visual Studio 16 2019",
  },
];

/**
 * Detect installed Visual Studio versions by checking common installation paths
 */
export async function detectInstalledVSVersions(): Promise<VSVersion[]> {
  if (Deno.build.os !== "windows") {
    return [];
  }

  const installedVersions: VSVersion[] = [];

  try {
    // Common Visual Studio installation base paths
    const basePaths = [
      join("C:", "Program Files", "Microsoft Visual Studio"),
      join("C:", "Program Files (x86)", "Microsoft Visual Studio"),
    ];

    // Check each supported version
    for (const vsVersion of SUPPORTED_VS_VERSIONS) {
      for (const basePath of basePaths) {
        // Try both Community, Professional, and Enterprise editions
        const editions = ["Community", "Professional", "Enterprise"];

        for (const edition of editions) {
          const fullPath = join(basePath, vsVersion.year, edition);

          try {
            const stat = await Deno.stat(fullPath);
            if (stat.isDirectory) {
              // Check if VC tools are installed
              const vcToolsPath = join(fullPath, "VC", "Tools", "MSVC");
              try {
                await Deno.stat(vcToolsPath);
                installedVersions.push({
                  ...vsVersion,
                  path: fullPath,
                });
                break; // Found this version, no need to check other editions
              } catch {
                // VC tools not found in this edition, try next
              }
            }
          } catch {
            // This path doesn't exist, try next
          }
        }
      }
    }
  } catch (error) {
    console.warn("‚ö†Ô∏è  Failed to detect Visual Studio versions:", error);
    return [];
  }

  return installedVersions;
}

/**
 * Get the latest installed Visual Studio version
 */
export async function getLatestVSVersion(): Promise<VSVersion | null> {
  const installed = await detectInstalledVSVersions();

  if (installed.length === 0) {
    return null;
  }

  // Return the first one (already sorted by newest first in SUPPORTED_VS_VERSIONS)
  return installed[0];
}

/**
 * Get Visual Studio generator by year
 */
export function getVSGeneratorByYear(year: string): string | null {
  const vsVersion = SUPPORTED_VS_VERSIONS.find((v) => v.year === year);
  return vsVersion ? vsVersion.generator : null;
}

/**
 * Validate Visual Studio version string
 */
export function isValidVSVersion(version: string): boolean {
  return SUPPORTED_VS_VERSIONS.some((v) => v.year === version);
}

/**
 * Get default Visual Studio generator
 * If version is specified, use it. Otherwise, auto-detect the latest.
 */
export async function getDefaultVSGenerator(
  specifiedVersion?: string
): Promise<string> {
  // If version is explicitly specified
  if (specifiedVersion) {
    if (!isValidVSVersion(specifiedVersion)) {
      throw new Error(
        \`Invalid Visual Studio version: \${specifiedVersion}. Supported: \${
          SUPPORTED_VS_VERSIONS.map((v) => v.year).join(", ")
        }\`
      );
    }
    return getVSGeneratorByYear(specifiedVersion)!;
  }

  // Auto-detect the latest installed version
  const latest = await getLatestVSVersion();

  if (latest) {
    console.log(
      \`‚úÖ Auto-detected Visual Studio \${latest.year} at: \${latest.path}\`
    );
    return latest.generator;
  }

  // Fallback to VS 2022 if auto-detection fails
  console.warn(
    "‚ö†Ô∏è  Could not auto-detect Visual Studio. Falling back to Visual Studio 2022."
  );
  return "Visual Studio 17 2022";
}
`;
}

export function generateJuceCMakeTypes(): string {
  return `/**
 * CMake File API v1 response type definitions
 */
export interface FileAPIIndex {
  cmake: {
    version: {
      string: string;
      major: number;
      minor: number;
      patch: number;
    };
  };
  objects: Array<{
    kind: string;
    version: { major: number; minor: number };
    jsonFile: string;
  }>;
  reply: {
    [key: string]: {
      kind: string;
      version: { major: number; minor: number };
      jsonFile: string;
    };
  };
}

export interface CodeModelV2 {
  version: { major: number; minor: number };
  paths: {
    source: string;
    build: string;
  };
  configurations: Array<{
    name: string;
    targets: Array<{
      name: string;
      id: string;
      type: string;
      jsonFile: string;
    }>;
  }>;
}

export interface TargetInfo {
  name: string;
  type: "EXECUTABLE" | "STATIC_LIBRARY" | "SHARED_LIBRARY" | "MODULE_LIBRARY" | "OBJECT_LIBRARY";
  artifacts?: Array<{
    path: string;
  }>;
  nameOnDisk?: string;
  sources?: Array<{
    path: string;
  }>;
  dependencies?: Array<{
    id: string;
  }>;
}

export interface BuildArtifact {
  name: string;
  type: string;
  path: string;
}
`;
}

// =============================================================================
// JUCE Plugin Source Files
// =============================================================================

export function generatePluginProcessorH(config: JucePluginConfig): string {
  return `#pragma once

#include <juce_audio_processors/juce_audio_processors.h>

//==============================================================================
class ${config.namePascal}AudioProcessor final : public juce::AudioProcessor
{
public:
    //==============================================================================
    ${config.namePascal}AudioProcessor();
    ~${config.namePascal}AudioProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    using AudioProcessor::processBlock;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    //==============================================================================
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

private:
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (${config.namePascal}AudioProcessor)
};
`;
}

export function generatePluginProcessorCpp(config: JucePluginConfig): string {
  return `#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
${config.namePascal}AudioProcessor::${config.namePascal}AudioProcessor()
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
                     #endif
                       )
{
}

${config.namePascal}AudioProcessor::~${config.namePascal}AudioProcessor()
{
}

//==============================================================================
const juce::String ${config.namePascal}AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool ${config.namePascal}AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool ${config.namePascal}AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool ${config.namePascal}AudioProcessor::isMidiEffect() const
{
   #if JucePlugin_IsMidiEffect
    return true;
   #else
    return false;
   #endif
}

double ${config.namePascal}AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int ${config.namePascal}AudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int ${config.namePascal}AudioProcessor::getCurrentProgram()
{
    return 0;
}

void ${config.namePascal}AudioProcessor::setCurrentProgram (int index)
{
    juce::ignoreUnused (index);
}

const juce::String ${config.namePascal}AudioProcessor::getProgramName (int index)
{
    juce::ignoreUnused (index);
    return {};
}

void ${config.namePascal}AudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    juce::ignoreUnused (index, newName);
}

//==============================================================================
void ${config.namePascal}AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

void ${config.namePascal}AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

bool ${config.namePascal}AudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    // This is the place where you check if the layout is supported.
    // In this template code we only support mono or stereo.
    // Some plugin hosts, such as certain GarageBand versions, will only
    // load plugins that support stereo bus layouts.
    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()
     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
        return false;

    // This checks if the input layout matches the output layout
   #if ! JucePlugin_IsSynth
    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())
        return false;
   #endif

    return true;
  #endif
}

void ${config.namePascal}AudioProcessor::processBlock (juce::AudioBuffer<float>& buffer,
                                              juce::MidiBuffer& midiMessages)
{
    juce::ignoreUnused (midiMessages);

    juce::ScopedNoDenormals noDenormals;
    auto totalNumInputChannels  = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();

    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // This is here to avoid people getting screaming feedback
    // when they first compile a plugin, but obviously you don't need to keep
    // this code if your algorithm always overwrites all the output channels.
    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    // Make sure to reset the state if your inner loop is processing
    // the samples and the outer loop is handling the channels.
    // Alternatively, you can process the samples with the channels
    // interleaved by keeping the same state.
    for (int channel = 0; channel < totalNumInputChannels; ++channel)
    {
        auto* channelData = buffer.getWritePointer (channel);
        juce::ignoreUnused (channelData);
        // ..do something to the data...
    }
}

//==============================================================================
bool ${config.namePascal}AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

juce::AudioProcessorEditor* ${config.namePascal}AudioProcessor::createEditor()
{
    return new ${config.namePascal}AudioProcessorEditor (*this);
}

//==============================================================================
void ${config.namePascal}AudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    juce::ignoreUnused (destData);
}

void ${config.namePascal}AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    juce::ignoreUnused (data, sizeInBytes);
}

//==============================================================================
// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ${config.namePascal}AudioProcessor();
}
`;
}

export function generatePluginEditorH(config: JucePluginConfig): string {
  return `#pragma once

#include "PluginProcessor.h"

//==============================================================================
class ${config.namePascal}AudioProcessorEditor final : public juce::AudioProcessorEditor
{
public:
    explicit ${config.namePascal}AudioProcessorEditor (${config.namePascal}AudioProcessor&);
    ~${config.namePascal}AudioProcessorEditor() override;

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;

private:
    // This reference is provided as a quick way for your editor to
    // access the processor object that created it.
    ${config.namePascal}AudioProcessor& processorRef;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (${config.namePascal}AudioProcessorEditor)
};
`;
}

export function generatePluginEditorCpp(config: JucePluginConfig): string {
  return `#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
${config.namePascal}AudioProcessorEditor::${config.namePascal}AudioProcessorEditor (${config.namePascal}AudioProcessor& p)
    : AudioProcessorEditor (&p), processorRef (p)
{
    juce::ignoreUnused (processorRef);
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (400, 300);
}

${config.namePascal}AudioProcessorEditor::~${config.namePascal}AudioProcessorEditor()
{
}

//==============================================================================
void ${config.namePascal}AudioProcessorEditor::paint (juce::Graphics& g)
{
    // (Our component is opaque, so we must completely fill the background with a solid colour)
    g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId));

    g.setColour (juce::Colours::white);
    g.setFont (15.0f);
    g.drawFittedText ("${config.name}", getLocalBounds(), juce::Justification::centred, 1);
}

void ${config.namePascal}AudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
}
`;
}

// =============================================================================
// Git
// =============================================================================

export function generateJuceGitignore(): string {
  return `# Build directories
build/
builds/
out/

# JUCE library (cloned during generation)
External/JUCE/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Deno
deno.lock

# CMake
CMakeCache.txt
CMakeFiles/
cmake_install.cmake
compile_commands.json
Makefile

# Compiled binaries
*.exe
*.dll
*.so
*.dylib
*.a
*.lib
*.o
*.obj

# Plugin formats
*.vst3
*.component
*.app
`;
}
